<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>The Perlang Programming Language </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="The Perlang Programming Language ">
    <meta name="generator" content="docfx 2.51.0.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <link rel="stylesheet" href="styles/asciinema-player.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="the-perlang-programming-language">The Perlang Programming Language</h1>

<h2 id="introduction">Introduction</h2>
<p>Welcome to the Perlang documentation. In this documentation, we try to describe both what Perlang <em>is</em> and what it aims to <em>become</em>. We try to make the distinction betwen these clear, when relevant.</p>
<h2 id="background---why-perlang">Background - Why Perlang?</h2>
<p>Perlang - <em>The Per Language</em> - was born in my heart sometime around 2017-2018. I had been working as a programmer for a long time, working with languages like Perl, Java, PHP, C++ and C#. At this time for me, my focus had largely moved over to spending a lot of time reading and writing Ruby code. I also did some marginal CoffeeScript or JavaScript work occasionally.</p>
<p>Some of these languages felt inherently more pleasant to work with than others. I also heard people complaining about languages like Java being overly verbose. As for me, I hadn&#39;t done very much Java programming since working with it a long time ago.</p>
<p>Of the languages mentioned, Ruby was a language that <em>particularly</em> made me frustrated and annoyed. If you don&#39;t know Ruby from beforehand, it&#39;s a dynamically typed scripting language, often used for writing web application backends (with &quot;Ruby on Rails&quot;, which is a highly popular web application framework written in Ruby). Ruby definitely has its strengths, and a few years later, I started to appreciate it much more, perhaps because I was now using it for use cases where it was an even better fit than for my previous projects.</p>
<h2 id="things-i-was-missing-in-ruby">Things I was missing in Ruby</h2>
<h3 id="optional-typing">Optional typing</h3>
<p>Ruby is a dynamically typed language, so variables, fields and method parameters are inherently untyped. However, unlike modern languages like <a href="https://www.typescriptlang.org/">TypeScript</a> that provide a way to add an &quot;optional&quot; type specifier for a variable or parameter, Ruby provides no such mechanism. Why is this a problem?</p>
<p>Well, it doesn&#39;t have to be, depending on whether you are dynamically or statically inclined as a person. But regardless of our personal preferences, types <em>exist</em>. They are real. It&#39;s not like they don&#39;t exist in a dynamically typed language, it&#39;s just that all the type checking has been deferred to a later stage - to runtime.</p>
<p>For me, when writing code, I tend to think about what type of objects a method will receive. A simple example to get you going:</p>
<pre><code class="lang-ruby">def do_something(s)
  s.swapcase
end
</code></pre><p>Perhaps I know when writing the code above that the <em>only</em> valid type of parameter for this method is really a String. (Yes, I know that this is the wrong way to think about Ruby code because you should not care about the particular type, instead just that it &quot;quacks like a duck&quot; and responds to the <code>swapcase</code> message. But there are still cases where you <em>must</em> enforce the type, for example because the data is being converted to JSON (and you don&#39;t want the result to be arbitrarily typed), sent to a database (where columns are typically using a fixed data type), etc.)</p>
<p>When I write Ruby code, I&#39;m essentially forced to <strong>throw away</strong> this information in my mind when writing the code. There is absolutely no way to write down in my program&#39;s source code what type a given parameter is expected to be of. For me, this is frustrating since it means that in the conversion from a mental model (in my head) to source code, I am essentially <em>forced</em> to remove information. Not redundant information, but actually information that would help the computer run my program in a more efficient way.</p>
<p>This leads us naturally over to my next point, namely:</p>
<h3 id="static-type-analysis">Static type analysis</h3>
<p>When a program contains type information, from one of the following sources:</p>
<ul>
<li>For <em>all variables/parameters</em> because of explicit typing (i.e. as in traditional, statically typed languages like Java, C# and C++)</li>
<li>For all/most variables/parameters because of <em>strong inferred typing</em> (as in languages like F#)</li>
<li>For <em>some</em> variables/parameters because of optional typing</li>
</ul>
<p>...it can use this information about the typing information to perform static analysis. For example, it can determine that the following Java program is invalid:</p>
<pre><code class="lang-java">var s = &quot;Hej hej&quot;;

// Produces the following error in JShell 11.0.6:
//
// cannot find symbol
//   symbol:   method nonExistingMethod()
s.nonExistingMethod();
</code></pre><p>This is because even though <code>s</code> is using an <em>inferred</em> type in this case, the compiler knows that this variable will <strong>always</strong> contain a String (or <code>null</code>). That way, it can statically determine that the <code>s.nonExistingMethod()</code> method call will always fail. There is simply <em>no way</em> for it to succeed, under any circumstances whatsoever.</p>
<p>Why is this important? It is important because typically, it&#39;s better if a program fails <em>as early as possible</em> rather than deferring potential failures to runtime checking. We call this the <a href="https://en.wikipedia.org/wiki/Fail-fast">&quot;fail fast&quot;</a> philosophy.</p>
<p>As systems grow in size, this becomes more and more important. Simply put, it gives you an extra level of comfort where you can trust the compiler to find errors in your program. Not <em>all</em> errors unfortunately, but at least a good deal of them.</p>
<p>What if we could extend these concepts further to let the compiler make an even more extensive analysis of the program? This is definitely an area we want to delve further into as we explore what Perlang will become.</p>
<h3 id="static-dispatch-of-methods">Static dispatch of methods</h3>
<p>Ruby uses an extreme form of &quot;dynamic dispatch&quot; when it comes to calling methods. The following program is completely valid:</p>
<pre><code class="lang-ruby">def foo
  # Note how this method is calling another, non-existent method
  bar(123)
end

puts(&quot;Hello world&quot;)
</code></pre><p>If you save this to a file <code>foo.rb</code> and run <code>ruby foo.rb</code>, the program will run without any errors whatsoever, even though the <code>foo</code> method referenced a method does that does not exist. This is because of how method invocations work in Ruby; all method calls are by definition &quot;legal&quot;, even when they refer to methods that do not exist. If you call an undefined method, there is even a nice little mechanism called <code>method_missing</code> which lets you define, in any class, a method called <code>method_missing</code>. All calls to non-existing methods will then be delegated to that method. An example:</p>
<pre><code class="lang-ruby">def foo
  bar(123)
end

def method_missing(method_name, *args)
  puts &quot;You called #{method_name} with #{args}&quot;
end

# (Note: parentheses for method calls are not mandatory in Ruby. The
# line below calls the &quot;foo&quot; method defined above.)
foo
</code></pre><p>Running the program above yields the following output:</p>
<pre><code class="lang-shell">$ ruby foo.rb
You called bar with [123]
</code></pre><p>Nice, huh? This functionality is what powers some of the existing <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL:s</a> written in Ruby, like som parts of the <a href="https://github.com/jeremyevans/sequel">Sequel</a> library.</p>
<p>I want to make it clear here that I <em>do</em> think it&#39;s good to have this kind of functionality in the language sometimes, but the bad part about it is that there&#39;s absolutely no way to &quot;turn it off&quot; for cases where you would prefer a <code>use strict</code>-mode or similar. I have had cases when there was a typo in a method call or field/variable reference where this was not caught by the unit tests, and I released an updated version of an (internal) Ruby gem - only to realize my folly a bit later.</p>
<p>It is my strong conviction that a really good programming language should help you avoid easy mistakes like this.</p>
<h2 id="consequences-of-the-above">Consequences of the above</h2>
<h3 id="excessive-reliance-on-unit-tests-to-detect-all-errors">Excessive reliance on unit tests to detect all errors</h3>
<p>Because of the lack of static analysis of the code (or at least a very weak analysis of it), people in the Ruby camp rely heavily on unit tests for finding software errors. This is not necessarily a bad thing in itself, since unit tests are great and I definitely think the world is better <em>with</em> unit tests than without them, but the thing I <em>don&#39;t</em> like is that with Ruby, you are essentially forced to go for at least 100% code coverage to even know that your code is at all <em>remotely</em> working. There are so many small things that can be broken if you ignore this.</p>
<p>There is a joke in the industry saying that &quot;if it compiles, ship it&quot;. Even though this is indeed a joke, there is still a valid point in it. If a computer system <em>compiles</em>, it&#39;s not at last fundamentally broken in that methods or classes are being referred to using the wrong name, or silly things like that. The compiler gives you a certain safety net, and I personally find that very valuable. With Perlang, we will strive to make this safety net as comfortable and convenient for you as a developer as possible.</p>
<h3 id="inferior-toolingide-support">Inferior tooling/IDE support</h3>
<p>The tooling and IDE support is also inherently more limited because of the above (which I consider a limitation in the Ruby language). Yes, editors like VS Code do their best to try and cover up for this, but it still feels limited.</p>
<p>RubyMine is a world of its own, and I must admit I feel sorry I never tried it while I was living in Ruby land. After having used JetBrains InteliJ (for Java) for a couple of years at work and Rider (for C#) also for some time, I know what kind of quality the JetBrains tools typically deliver.</p>
<p>But still: you can only get so far when the language doesn&#39;t implement the <em>feature</em> that is static typing. Yes, I consider static typing a feature, very much so.</p>
<h3 id="inferior-performance">Inferior performance</h3>
<p>Typing information is not just valuable to humans when they read the source code of your program. It is also an invaluable source of knowledge about very intricate details about the inner workings of your program, which can be of great use to make it run as efficiently as possible. It also goes the other way around: when you <em>know</em> the details about how the data in your program is stored in memory, you can use this knowledge to your benefit.</p>
<p>Take the following C# class as an example:</p>
<pre><code class="lang-c#">public class Foo
{
    public string bar;
    public string baz;
    public Zot zot;

    // ...other data fields.
}

public struct Zot
{
    public int x;
    public int y;
}
</code></pre><p>Because structs typically use a sequential layout in .NET, the above roughly translates to something like this in memory:</p>
<pre><code>0000000000000000: 64-bit pointer to bar
0000000000000008: 64-bit pointer to baz
0000000000000010: 32-bit value of x
0000000000000014: 32-bit value of y
</code></pre><p>Do you get what I mean? The <code>x</code> and <code>y</code> fields get inlined here, which means all the data is nicely available here in a co-located manner.</p>
<p>Imagine if this was a Ruby program instead. The memory layout would perhaps be something like this:</p>
<pre><code>0000000000000000: 64-bit pointer to bar
0000000000000008: 64-bit pointer to baz
0000000000000010: 64-bit pointer to zot

...[somewhere completely else on the heap]...

0000000000100000: 32-bit value of x
0000000000100004: 32-bit value of y
</code></pre><p>Now, I&#39;ll admit, this really doesn&#39;t have anything with <em>static typing</em> to do per se; it&#39;s more an argument for languages with value types (like C#). Other languages like Java do not support it at the moment (although <a href="https://openjdk.java.net/jeps/169">JEP 169</a> proposes it in that specific case)</p>
<p>But the point is this: static typing <em>enables</em> more advanced features like this. Dynamically typed languages will likely always have slightly inferior performance than statically typed languages, although companies and highly motivated individuals alike are working as hard as they can to diminish the size of the gap all the time.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/perlang-org/perlang/blob/1d436ac29495024ba09a632d068d3bcca0dea49a/docs/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            © Copyright 2020 The Perlang Authors
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
    <script type="text/javascript" src="js/asciinema-player.js"></script>
  </body>
</html>
